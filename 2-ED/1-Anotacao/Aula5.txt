Big O 
-> É uma notação matemática usada para descrever o comportamento de um algoritmo, principalmente em termos de complexidade temporal (quanto tempo ele vai levar para ser executado) e complexidade espacial (quanto de memória ele vai precisar). Essa notação é crucial para analisar a eficiência de algoritmos, especialmente em cenários de grandes entradas de dados.

Complexidade temporal: Quanto tempo um algoritmo leva para rodar em função do tamanho da entrada.
Complexidade espacial: Quanto espaço (memória) o algoritmo precisa para rodar.

Importância do Big O

Desenvolvimento de software de alta qualidade: Ao escolher o algoritmo certo para um problema, podemos garantir que ele será eficiente e escalável.
Melhoria da performance: Compreender a complexidade de um algoritmo ajuda a encontrar soluções mais rápidas e econômicas em termos de memória.
Escolha de algoritmos: Saber a complexidade ajuda a escolher o algoritmo adequado para diferentes cenários, como grandes volumes de dados, tempo de resposta crítico, ou mesmo a quantidade de memória disponível.

Niveis de complexidade:

O(1) - Constante:
Exemplo: Acesso direto a um elemento de um array.
Significa que, independentemente do tamanho da entrada (n), o tempo de execução é sempre o mesmo.

O(n) - Linear:
Exemplo: Percorrer todos os elementos de um array.
O tempo de execução cresce linearmente com o aumento do tamanho da entrada.

O(log n) - Logarítmica:
Exemplo: Busca binária.
A complexidade logarítmica significa que o número de operações aumenta muito mais devagar em comparação com a entrada. Geralmente, isso ocorre quando você divide a entrada de alguma forma.

O(n²) - Quadrática:
Exemplo: Algoritmos de ordenação como Selection Sort, Insertion Sort e Bubble Sort.
O tempo de execução cresce de forma quadrática com o tamanho da entrada, ou seja, o tempo de execução dobra para cada aumento pequeno na entrada.

O(n!) - Fatorial:
Exemplo: Algoritmos que exploram todas as permutações possíveis de um conjunto (como a solução para o problema do caixeiro viajante).
O crescimento fatorial é muito rápido e os algoritmos com essa complexidade geralmente são muito ineficientes para grandes entradas.