Big O 
-> É uma notação matemática usada para descrever o comportamento de um algoritmo, principalmente em termos de complexidade temporal (quanto tempo ele vai levar para ser executado) e complexidade espacial (quanto de memória ele vai precisar). Essa notação é crucial para analisar a eficiência de algoritmos, especialmente em cenários de grandes entradas de dados.

Complexidade temporal: Quanto tempo um algoritmo leva para rodar em função do tamanho da entrada.
Complexidade espacial: Quanto espaço (memória) o algoritmo precisa para rodar.

Importância do Big O

Desenvolvimento de software de alta qualidade: Ao escolher o algoritmo certo para um problema, podemos garantir que ele será eficiente e escalável.

Melhoria da performance: Compreender a complexidade de um algoritmo ajuda a encontrar soluções mais rápidas e econômicas em termos de memória.

Escolha de algoritmos: Saber a complexidade ajuda a escolher o algoritmo adequado para diferentes cenários, como grandes volumes de dados, tempo de resposta crítico, ou mesmo a quantidade de memória disponível.

Ex:
->  Encontrar uma pagina no meio de um livro (em qualquer parte)

    Busca Linear -> Percorre pagina por pagina até encontrar
    Complexidade: O(n)

    Busca Binária ->    Divido o meio do livro
                        Se a página em questão for maior que o meio, descarto a parte inferior
                        Se a página em questão for menor que o meio, descarto a parte superior

                        Faço essa divisão novamente na parte divida, até encontrar a pagina exatamente (meio)
    Complexidade: O(log n)

Outras complexidades:

Complexidade Constante - O(1)
->  Independentemente da entrada de dados, o tempo não vai mudar
    Ex:
    ->  Acessar o 1 elemento de uma lista (vetor)
 
Complexidade Quadrática - O(n2)
->  Quando o tempo de execução aumenta quadraticamente em relação aos dados
    Ex: Quando o programa compara um numero com todos os elementos e repete essa ação
    Ex: Bubble Sort -> Laços aninhados
    Ex: Comparar se o elemento de um array é menor que o proximo elemento...

Complexidade Exponencial - O(2n)
->  Quando o tempo cresce exponencialmente em relação aos dados
    Ex: Encontrar ou decifrar a senha de um cadeado com 3 digitios
        Cada digito ou combinação de digitos crescem
        
        Ex: Algoritmo de Fibonacci -> Começam com 0 e 1, e os proximos são a soma dos 2 anteriores

    Ex: Encontrar os numeros duplicados dentro de um array
        Pega cada elemento por vez, e verifica se tem valores iguais a ele