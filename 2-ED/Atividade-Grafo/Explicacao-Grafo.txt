1. O programa comeÃ§a pelo main()

Java sempre executa o mÃ©todo main primeiro.
EntÃ£o ele chega aqui:

public static void main(String[] args) {
    GrafoTuristicoSP_Ponderado grafo = new GrafoTuristicoSP_Ponderado();


ğŸ§© Nesse momento:

Um novo objeto do tipo GrafoTuristicoSP_Ponderado Ã© criado.
Isso chama o construtor da classe.

-------------------

2. O construtor Ã© executado
public GrafoTuristicoSP_Ponderado() {
    adjacencia = new HashMap<>();
}


ğŸ§  O que acontece aqui:

O grafo comeÃ§a vazio.

Cria-se um Map (dicionÃ¡rio) chamado adjacencia para guardar os vÃ©rtices e suas conexÃµes.

ğŸ“¦ Agora temos:

adjacencia = {}

-------------------

3. O programa cria a lista de pontos turÃ­sticos
String[] pontos = {
    "Avenida Paulista",
    "MASP",
    "Parque Ibirapuera",
    "Catedral da SÃ©",
    "Mercado Municipal",
    "Pinacoteca",
    "SÃ£o Bento",
    "Beco do Batman",
    "Farol Santander"
};


ğŸ§  Aqui sÃ³ estÃ¡ sendo criada uma lista de nomes (os vÃ©rtices do grafo).

-------------------

4. Cada ponto Ã© adicionado como vÃ©rtice
for (String p : pontos)
    grafo.adicionarVertice(p);


ğŸ” Esse laÃ§o for passa um por um e chama:

public void adicionarVertice(String vertice) {
    adjacencia.putIfAbsent(vertice, new ArrayList<>());
}


ğŸ§© O que acontece internamente:

O Java verifica se o vÃ©rtice jÃ¡ existe.

Se nÃ£o existir, adiciona ele ao mapa com uma lista vazia (sem conexÃµes ainda).

ğŸ“¦ ApÃ³s esse passo:

adjacencia = {
  "Avenida Paulista": [],
  "MASP": [],
  "Parque Ibirapuera": [],
  ...
}

--------------------

5. Agora o programa adiciona as arestas (ligaÃ§Ãµes)

Exemplo:

grafo.adicionarAresta("Avenida Paulista", "MASP", 0.3);


â¡ï¸ Chama o mÃ©todo:

public void adicionarAresta(String origem, String destino, double peso) {
    adjacencia.get(origem).add(new Aresta(destino, peso));
    adjacencia.get(destino).add(new Aresta(origem, peso)); // nÃ£o direcionado
}


ğŸ§  O que acontece aqui:

Pega a lista do vÃ©rtice â€œAvenida Paulistaâ€.

Adiciona dentro dela uma nova aresta que vai para â€œMASPâ€ com peso 0.3 km.

Faz o mesmo no sentido inverso (porque o grafo Ã© nÃ£o direcionado).

ğŸ“¦ Resultado parcial:

"Avenida Paulista" -> [("MASP", 0.3)]
"MASP" -> [("Avenida Paulista", 0.3)]


â¡ï¸ E o programa repete isso pra todas as conexÃµes que vocÃª definiu.


---------------------

6. Agora o grafo estÃ¡ completo

Depois que todas as arestas sÃ£o adicionadas, o Map interno fica mais ou menos assim:

{
  "Avenida Paulista": [("MASP", 0.3), ("Parque Ibirapuera", 2.0), ("Beco do Batman", 3.0)],
  "MASP": [("Avenida Paulista", 0.3), ("Parque Ibirapuera", 1.7)],
  "Catedral da SÃ©": [("Mercado Municipal", 1.0), ("Farol Santander", 0.8)],
  ...
}


Agora o grafo estÃ¡ completo e conectado.

------------------

7. O programa mostra a lista de adjacÃªncia
grafo.mostrarListaAdjacencia();


â¡ï¸ Entra nesse mÃ©todo:

for (String vertice : adjacencia.keySet()) {
    System.out.print(vertice + " -> ");
    for (Aresta a : adjacencia.get(vertice)) {
        System.out.print(a.destino + "(" + a.peso + " km) ");
    }
    System.out.println();
}


ğŸ§  O que ele faz:

Pega cada vÃ©rtice.

Mostra quem estÃ¡ ligado a ele e as distÃ¢ncias.

ğŸ–¨ï¸ Exemplo de saÃ­da:

Avenida Paulista -> MASP(0.3 km) Parque Ibirapuera(2.0 km) Beco do Batman(3.0 km)
MASP -> Avenida Paulista(0.3 km) Parque Ibirapuera(1.7 km)

----------------------

8. O programa mostra todas as arestas (sem repetir)
grafo.mostrarArestas();


â¡ï¸ Esse mÃ©todo:

Percorre todos os vÃ©rtices.

Para cada um, mostra suas ligaÃ§Ãµes.

Usa um Set chamado exibidas para nÃ£o repetir arestas (ex: â€œMASP â€” Paulistaâ€ e â€œPaulista â€” MASPâ€).

ğŸ§© Internamente:

if (!exibidas.contains(reversa)) {
    System.out.println(v + " â€” " + a.destino + " : " + a.peso + " km");
    exibidas.add(aresta);
}


ğŸ–¨ï¸ Exemplo de saÃ­da:

=== ARESTAS DO GRAFO ===
Avenida Paulista â€” MASP : 0.3 km
Avenida Paulista â€” Parque Ibirapuera : 2.0 km
MASP â€” Parque Ibirapuera : 1.7 km

------------------------




































